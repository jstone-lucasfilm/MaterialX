#!/usr/bin/env python
'''
Analyze a DOT file generated by analyze_cpp_includes.py to find duplicate includes.

This script finds cases where a header file is included both directly and
transitively (through other includes) from the same source file.
'''

import re
import argparse
import os
import sys
from collections import defaultdict, deque
from pathlib import Path


def parseDotFile(dotFile):
    '''Parse a DOT file and extract the dependency graph.'''
    graph = defaultdict(set)

    # Pattern to match edge declarations: "source" -> "target";
    edgePattern = re.compile(r'^\s*"([^"]+)"\s*->\s*"([^"]+)"', re.MULTILINE)

    try:
        with open(dotFile, 'r', encoding='utf-8') as f:
            content = f.read()

        # Find all edges
        for match in edgePattern.finditer(content):
            source = match.group(1)
            target = match.group(2)
            graph[source].add(target)

    except Exception as err:
        print("Error reading DOT file: %s" % err)
        return {}

    return graph


def findTransitiveDependencies(graph, source, maxDepth=None):
    '''
    Find all transitive dependencies of a source file.
    Returns a dictionary mapping each dependency to its shortest path length.
    '''
    dependencies = {}
    visited = set()
    queue = deque([(source, 0)])

    while queue:
        current, depth = queue.popleft()

        if current in visited:
            continue
        visited.add(current)

        # Skip if we've exceeded max depth
        if maxDepth and depth > maxDepth:
            continue

        # Process direct dependencies of current file
        if current in graph:
            for target in graph[current]:
                # Track the shortest path to each dependency
                if target not in dependencies or dependencies[target] > depth + 1:
                    dependencies[target] = depth + 1

                # Add to queue if not visited
                if target not in visited:
                    queue.append((target, depth + 1))

    return dependencies


def findAllPathsBetween(graph, start, end, maxDepth=10):
    '''Find all paths between start and end nodes in the graph.'''
    paths = []
    visited = set()

    def dfs(current, target, path):
        if len(path) > maxDepth:
            return

        if current == target and len(path) > 1:
            paths.append(list(path))
            return

        if current in visited:
            return

        visited.add(current)

        if current in graph:
            for neighbor in graph[current]:
                path.append(neighbor)
                dfs(neighbor, target, path)
                path.pop()

        visited.remove(current)

    dfs(start, end, [start])
    return paths


def analyzeDuplicateIncludes(dotFile, verbose=False, outputFile=None):
    '''Main analysis function.'''
    print("Parsing DOT file: %s" % dotFile)
    graph = parseDotFile(dotFile)

    if not graph:
        print("Error: Could not parse DOT file or file is empty")
        return

    print("Found %d files with dependencies" % len(graph))
    print("Analyzing for duplicate includes...\n")

    # Track unique duplicate pairs
    duplicatePairs = {}

    for source in graph:
        directIncludes = graph[source]

        for target in directIncludes:
            # For each direct include, find if it's also included transitively
            for intermediate in directIncludes:
                if intermediate != target and intermediate in graph:
                    # Check if target is reachable from intermediate
                    intermediateDeps = findTransitiveDependencies(graph, intermediate)
                    if target in intermediateDeps:
                        # Create a unique key for this duplicate
                        key = (source, target)
                        if key not in duplicatePairs:
                            duplicatePairs[key] = {
                                'source': source,
                                'target': target,
                                'intermediates': []
                            }
                        duplicatePairs[key]['intermediates'].append(intermediate)

    # Sort duplicates by source file for better readability
    sortedDuplicates = sorted(duplicatePairs.values(), key=lambda x: x['source'])

    if not sortedDuplicates:
        print("No duplicate includes found!")
        return

    print("Found %d duplicate include relationships:\n" % len(sortedDuplicates))
    print("=" * 80)

    for dup in sortedDuplicates:
        sourceBase = os.path.basename(dup['source'])
        targetBase = os.path.basename(dup['target'])

        print("\nFile: %s" % dup['source'])
        print("  Duplicate include: %s" % dup['target'])
        print("  - Included directly")
        print("  - Also included transitively through:")

        for intermediate in dup['intermediates'][:5]:  # Limit to first 5 intermediates
            intermediateBase = os.path.basename(intermediate)
            # Find the actual path
            if verbose:
                paths = findAllPathsBetween(graph, intermediate, dup['target'], maxDepth=5)
                if paths and paths[0]:
                    pathStr = " -> ".join([os.path.basename(p) for p in paths[0]])
                    print("    * %s" % intermediate)
                    print("      Path: %s" % pathStr)
            else:
                print("    * %s" % intermediate)

        if len(dup['intermediates']) > 5:
            print("    ... and %d more" % (len(dup['intermediates']) - 5))

    print("\n" + "=" * 80)
    print("\nSummary:")
    print("  Total duplicate includes: %d" % len(sortedDuplicates))

    # Count by source file
    sourceCount = defaultdict(int)
    for dup in sortedDuplicates:
        sourceCount[dup['source']] += 1

    # Show files with most duplicates
    topSources = sorted(sourceCount.items(), key=lambda x: x[1], reverse=True)[:5]
    if topSources:
        print("\n  Files with most duplicate includes:")
        for source, count in topSources:
            print("    - %s: %d duplicates" % (source, count))


def main():
    parser = argparse.ArgumentParser(
        description="Analyze DOT file for duplicate includes (direct + transitive)."
    )
    parser.add_argument("dotfile", nargs="?", default="cpp_includes.dot",
                       help="Input DOT file (default: cpp_includes.dot)")
    parser.add_argument("--verbose", "-v", action="store_true",
                       help="Show detailed paths for transitive includes")
    parser.add_argument("--output", "-o", dest="output",
                       help="Write output to file instead of stdout")

    opts = parser.parse_args()

    if not os.path.exists(opts.dotfile):
        print("Error: DOT file '%s' not found" % opts.dotfile)
        print("Please run 'analyze_cpp_includes.py' first to generate the DOT file")
        return 1

    # Redirect output if requested
    if opts.output:
        originalStdout = sys.stdout
        try:
            with open(opts.output, 'w', encoding='utf-8') as f:
                sys.stdout = f
                analyzeDuplicateIncludes(opts.dotfile, opts.verbose)
        finally:
            sys.stdout = originalStdout
            print("Output written to: %s" % opts.output)
    else:
        analyzeDuplicateIncludes(opts.dotfile, opts.verbose)

    return 0


if __name__ == '__main__':
    exit(main())
